{"file_contents":{"static/js/script.js":{"content":"document.addEventListener('DOMContentLoaded', function() {\n    // Get DOM elements\n    const uploadForm = document.getElementById('uploadForm');\n    const excelFileInput = document.getElementById('excelFile');\n    const numQuestionsInput = document.getElementById('numQuestions');\n    const numVersionsInput = document.getElementById('numVersions');\n    const generateBtn = document.getElementById('generateBtn');\n    const alertArea = document.getElementById('alertArea');\n    const downloadArea = document.getElementById('downloadArea');\n    const regularDownloadBtn = document.getElementById('regularDownloadBtn');\n    const highlightedDownloadBtn = document.getElementById('highlightedDownloadBtn');\n    const loadingOverlay = document.getElementById('loadingOverlay');\n    \n    // Form validation\n    uploadForm.addEventListener('submit', function(event) {\n        event.preventDefault();\n        \n        // Clear previous alerts\n        alertArea.innerHTML = '';\n        downloadArea.classList.add('d-none');\n        \n        // Validate form\n        if (!uploadForm.checkValidity()) {\n            event.stopPropagation();\n            uploadForm.classList.add('was-validated');\n            return;\n        }\n        \n        // Validate file type\n        const file = excelFileInput.files[0];\n        if (!file) {\n            showAlert('Vui lòng chọn một file Excel.', 'danger');\n            return;\n        }\n        \n        const fileExt = file.name.split('.').pop().toLowerCase();\n        if (fileExt !== 'xlsx' && fileExt !== 'xls') {\n            showAlert('Loại file không hợp lệ. Vui lòng tải lên file Excel (.xlsx hoặc .xls).', 'danger');\n            return;\n        }\n        \n        // Validate number inputs\n        const numQuestions = parseInt(numQuestionsInput.value);\n        const numVersions = parseInt(numVersionsInput.value);\n        \n        if (isNaN(numQuestions) || numQuestions <= 0) {\n            showAlert('Số câu hỏi phải là một số dương.', 'danger');\n            return;\n        }\n        \n        if (isNaN(numVersions) || numVersions <= 0) {\n            showAlert('Số phiên bản phải là một số dương.', 'danger');\n            return;\n        }\n        \n        // Show loading overlay\n        loadingOverlay.classList.remove('d-none');\n        \n        // Submit form data\n        const formData = new FormData(uploadForm);\n        \n        fetch('/upload', {\n            method: 'POST',\n            body: formData\n        })\n        .then(response => response.json())\n        .then(data => {\n            // Hide loading overlay\n            loadingOverlay.classList.add('d-none');\n            \n            if (data.error) {\n                // Show error message\n                showAlert(data.error, 'danger');\n            } else {\n                // Show success message\n                showAlert('Tạo file thành công! Bấm vào các nút bên dưới để tải xuống.', 'success');\n                \n                // Set download links\n                regularDownloadBtn.href = `/download/${data.regular_zip}`;\n                highlightedDownloadBtn.href = `/download/${data.highlighted_zip}`;\n                \n                // Show download area\n                downloadArea.classList.remove('d-none');\n            }\n        })\n        .catch(error => {\n            // Hide loading overlay\n            loadingOverlay.classList.add('d-none');\n            \n            // Show error message\n            showAlert('Đã xảy ra lỗi: ' + error.message, 'danger');\n            console.error('Error:', error);\n        });\n    });\n    \n    // Function to show alerts\n    function showAlert(message, type) {\n        alertArea.innerHTML = `\n            <div class=\"alert alert-${type} alert-dismissible fade show\" role=\"alert\">\n                ${message}\n                <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Close\"></button>\n            </div>\n        `;\n    }\n    \n    // File input change event for better UX\n    excelFileInput.addEventListener('change', function() {\n        if (this.files.length > 0) {\n            const fileName = this.files[0].name;\n            const fileSize = (this.files[0].size / 1024).toFixed(2);\n            \n            const fileLabel = this.nextElementSibling;\n            if (fileLabel) {\n                fileLabel.textContent = `${fileName} (${fileSize} KB)`;\n            }\n        }\n    });\n    \n    // Add input validation for number fields\n    numQuestionsInput.addEventListener('input', function() {\n        if (this.value < 1) {\n            this.value = 1;\n        }\n    });\n    \n    numVersionsInput.addEventListener('input', function() {\n        if (this.value < 1) {\n            this.value = 1;\n        }\n    });\n    \n    // Add example values for better UX\n    numQuestionsInput.placeholder = \"VD: 10\";\n    numVersionsInput.placeholder = \"VD: 2\";\n});\n","size_bytes":4925},"main.py":{"content":"from app import app\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=5000, debug=True)\n","size_bytes":99},"utils/document_generator.py":{"content":"import os\nimport zipfile\nimport tempfile\nfrom docx import Document\nfrom docx.shared import Pt, Inches, RGBColor\nfrom docx.enum.text import WD_ALIGN_PARAGRAPH\nfrom docx.enum.section import WD_ORIENTATION\nfrom docx.enum.section import WD_SECTION\nfrom docx.oxml import OxmlElement\nfrom docx.oxml.ns import qn\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef create_word_document(questions_df, highlight_answers=False, class_name=\"\", subject_name=\"\", version=0, num_columns=2):\n    \"\"\"\n    Creates a Word document with the given questions\n    If highlight_answers is True, the correct answers are highlighted\n    Optional class_name and subject_name parameters for document header\n    num_columns: Number of columns (1 or 2, default is 2)\n    \"\"\"\n    doc = Document()\n    \n    section = doc.sections[0]\n    \n    # Set orientation and margins based on number of columns\n    if num_columns == 1:\n        # For 1-column layout: use portrait orientation with standard margins\n        section.orientation = WD_ORIENTATION.PORTRAIT\n        section.left_margin = Inches(0.75)\n        section.right_margin = Inches(0.75)\n        section.top_margin = Inches(0.5)\n        section.bottom_margin = Inches(0.5)\n    else:\n        # For 2-column layout: use landscape orientation with narrow margins\n        section.orientation = WD_ORIENTATION.LANDSCAPE\n        section.left_margin = Inches(0.3)\n        section.right_margin = Inches(0.3)\n        section.top_margin = Inches(0.3)\n        section.bottom_margin = Inches(0.3)\n    \n    # Add document header with subject and class name\n    header = doc.add_paragraph()\n    header.alignment = WD_ALIGN_PARAGRAPH.CENTER\n    \n    # Create title text\n    title_text = \"ĐỀ THI\"\n    if subject_name:\n        title_text += f\" {subject_name}\"\n    if class_name:\n        title_text += f\" - {class_name}\"\n    \n    # Add the title in bold, centered\n    run = header.add_run(title_text)\n    run.bold = True\n    run.font.name = 'Times New Roman'\n    run.font.size = Pt(8)\n    \n    # Add version number centered\n    version_para = doc.add_paragraph()\n    version_para.alignment = WD_ALIGN_PARAGRAPH.CENTER\n    version_run = version_para.add_run(f\"Đề số {version + 1}\")  # version starts from 0 in code\n    version_run.bold = True\n    version_run.font.name = 'Times New Roman'\n    version_run.font.size = Pt(8)\n    \n    # Add student information section without underlines\n    info_para = doc.add_paragraph()\n    info_para.add_run(\"Mã sinh viên:                     Họ tên:                    \").font.name = 'Times New Roman'\n    info_para.add_run().font.size = Pt(8)\n    \n    # Add a small space after the student info section\n    doc.add_paragraph()\n    \n    # Set up column layout for questions section\n    section.start_type = WD_SECTION.NEW_PAGE\n    \n    # Create columns based on num_columns parameter\n    sectPr = section._sectPr\n    if not sectPr.xpath('./w:cols'):\n        cols = OxmlElement('w:cols')\n        cols.set(qn('w:num'), str(num_columns))\n        sectPr.append(cols)\n    else:\n        cols = sectPr.xpath('./w:cols')[0]\n        cols.set(qn('w:num'), str(num_columns))\n    \n    # Try to set font style as a default for the document\n    try:\n        style = doc.styles['Normal']\n        # We'll handle font formatting at the run level instead\n    except Exception as e:\n        logger.debug(f\"Error accessing style: {str(e)}\")\n        \n    # Process questions\n    total_questions = len(questions_df)\n    \n    for index, row in questions_df.iterrows():\n        # Add question number and text (in bold)\n        question_text = f\"{index + 1}. {row['Câu hỏi']}\"\n        paragraph = doc.add_paragraph()\n        paragraph.paragraph_format.space_after = Pt(1)  # Minimal space\n        \n        # Add question in bold with Times New Roman font\n        run = paragraph.add_run(question_text)\n        run.bold = True\n        run.font.name = 'Times New Roman'\n        run.font.size = Pt(8)  # Smaller font\n        \n        # Add options with minimal spacing and indentation\n        options = ['A', 'B', 'C', 'D']\n        correct_answer = row['đáp án']\n        \n        for option in options:\n            option_text = f\"{option}: {row[option]}\"\n            paragraph = doc.add_paragraph()\n            paragraph.paragraph_format.left_indent = Pt(8)  # Smaller indentation\n            paragraph.paragraph_format.space_before = Pt(0)\n            paragraph.paragraph_format.space_after = Pt(0)\n            \n            if highlight_answers and option == correct_answer:\n                # Highlight correct answer with bold\n                run = paragraph.add_run(option_text)\n                run.bold = True\n                run.font.name = 'Times New Roman'\n                run.font.size = Pt(8)\n            else:\n                run = paragraph.add_run(option_text)\n                run.font.name = 'Times New Roman'\n                run.font.size = Pt(8)\n        \n        # Add minimal separator between questions\n        p = doc.add_paragraph()\n        p.paragraph_format.space_before = Pt(0)\n        p.paragraph_format.space_after = Pt(1)\n    \n    return doc\n\ndef generate_zip_files(questions_df, num_questions, num_versions, class_name=\"\", subject_name=\"\"):\n    \"\"\"\n    Generates two ZIP files:\n    1. Regular version without highlighted answers\n    2. Version with highlighted answers\n    \n    Each version contains both 1-column and 2-column layouts\n    \n    Returns dictionary with paths to both ZIP files\n    \"\"\"\n    temp_dir = tempfile.gettempdir()\n    \n    # Create unique filenames for the ZIP files\n    regular_zip_filename = f\"regular_quiz_{num_questions}q_{num_versions}v.zip\"\n    highlighted_zip_filename = f\"highlighted_quiz_{num_questions}q_{num_versions}v.zip\"\n    \n    regular_zip_path = os.path.join(temp_dir, regular_zip_filename)\n    highlighted_zip_path = os.path.join(temp_dir, highlighted_zip_filename)\n    \n    # Create both ZIP files\n    with zipfile.ZipFile(regular_zip_path, 'w') as regular_zip, \\\n         zipfile.ZipFile(highlighted_zip_path, 'w') as highlighted_zip:\n        \n        for version in range(1, num_versions + 1):\n            # Get random questions for this version\n            version_questions = get_random_questions(questions_df, num_questions)\n            \n            # Create documents for both 1-column and 2-column layouts\n            for num_cols in [2, 1]:  # 2 columns first, then 1 column\n                col_suffix = f\"{num_cols}col\"\n                \n                # Create regular document with class and subject name\n                regular_doc = create_word_document(\n                    version_questions, \n                    highlight_answers=False,\n                    class_name=class_name,\n                    subject_name=subject_name,\n                    version=version-1,  # version-1 because version starts at 1 in the loop\n                    num_columns=num_cols\n                )\n                \n                # Create highlighted document with class and subject name\n                highlighted_doc = create_word_document(\n                    version_questions, \n                    highlight_answers=True,\n                    class_name=class_name,\n                    subject_name=subject_name,\n                    version=version-1,  # version-1 because version starts at 1 in the loop\n                    num_columns=num_cols\n                )\n                \n                # Save documents to temporary files\n                regular_doc_path = os.path.join(temp_dir, f\"quiz_version_{version}_{col_suffix}.docx\")\n                highlighted_doc_path = os.path.join(temp_dir, f\"quiz_version_{version}_{col_suffix}_answers.docx\")\n                \n                regular_doc.save(regular_doc_path)\n                highlighted_doc.save(highlighted_doc_path)\n                \n                # Add documents to ZIP files\n                regular_zip.write(regular_doc_path, f\"quiz_version_{version}_{col_suffix}.docx\")\n                highlighted_zip.write(highlighted_doc_path, f\"quiz_version_{version}_{col_suffix}_answers.docx\")\n                \n                # Clean up temporary document files\n                os.remove(regular_doc_path)\n                os.remove(highlighted_doc_path)\n    \n    return {\n        'regular': regular_zip_filename,\n        'highlighted': highlighted_zip_filename\n    }\n\ndef get_random_questions(df, num_questions):\n    \"\"\"\n    Gets a random sample of questions from the dataframe.\n    If \"Phân loại\" column exists, ensures at least 1 question from each category.\n    \"\"\"\n    import pandas as pd\n    \n    # Check if \"Phân loại\" column exists\n    if 'Phân loại' not in df.columns:\n        # No category column, use simple random selection\n        return df.sample(n=num_questions).reset_index(drop=True)\n    \n    # Get unique categories\n    categories = df['Phân loại'].unique()\n    num_categories = len(categories)\n    \n    # Check if we have enough questions to cover all categories\n    if num_questions < num_categories:\n        raise ValueError(f'Số câu hỏi ({num_questions}) phải lớn hơn hoặc bằng số phân loại ({num_categories}) để đảm bảo mỗi phân loại có ít nhất 1 câu hỏi')\n    \n    # Select at least 1 question from each category\n    selected_questions = []\n    selected_indices = []\n    \n    for category in categories:\n        category_questions = df[df['Phân loại'] == category]\n        # Randomly select 1 question from this category\n        sampled = category_questions.sample(n=1)\n        selected_questions.append(sampled)\n        selected_indices.extend(sampled.index.tolist())\n    \n    # Calculate remaining questions to select\n    remaining_questions = num_questions - num_categories\n    \n    if remaining_questions > 0:\n        # Create a pool of remaining questions (all questions except already selected)\n        remaining_df = df[~df.index.isin(selected_indices)]\n        \n        # Randomly select the remaining questions\n        additional_questions = remaining_df.sample(n=remaining_questions)\n        \n        # Add to selected questions\n        selected_questions.append(additional_questions)\n    \n    # Combine all selected questions\n    result_df = pd.concat(selected_questions, ignore_index=True)\n    \n    # Shuffle the final result to mix categories\n    result_df = result_df.sample(frac=1).reset_index(drop=True)\n    \n    return result_df\n","size_bytes":10389},"utils/excel_processor.py":{"content":"import pandas as pd\nimport numpy as np\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef validate_excel_format(df):\n    \"\"\"\n    Validates that a dataframe has the required columns and format\n    \"\"\"\n    try:\n        # Define required columns\n        required_columns = ['Câu hỏi', 'A', 'B', 'C', 'D', 'đáp án']\n        \n        # Check if all required columns are present\n        missing_columns = [col for col in required_columns if col not in df.columns]\n        if missing_columns:\n            return {'error': f'Thiếu các cột yêu cầu: {\", \".join(missing_columns)}'}\n        \n        # Check if any required columns are empty\n        empty_columns = []\n        for col in required_columns:\n            # Check if the column has any NaN values\n            if pd.isna(df[col]).any(skipna=False):\n                empty_columns.append(col)\n        \n        if empty_columns:\n            return {'error': f'Các cột sau đây chứa giá trị trống: {\", \".join(empty_columns)}'}\n        \n        # Validate answer column values\n        valid_answers = ['A', 'B', 'C', 'D']\n        # Check for invalid answers\n        invalid_answers = []\n        for answer in df['đáp án'].unique():\n            if answer not in valid_answers:\n                invalid_answers.append(str(answer))\n        \n        if len(invalid_answers) > 0:\n            return {'error': f'Tìm thấy giá trị đáp án không hợp lệ: {\", \".join(invalid_answers)}. Đáp án hợp lệ là: A, B, C, D'}\n        \n        # Check if \"Phân loại\" column exists and has empty values\n        if 'Phân loại' in df.columns:\n            if pd.isna(df['Phân loại']).any():\n                return {'error': 'Cột \"Phân loại\" chứa giá trị trống. Vui lòng điền đầy đủ phân loại cho tất cả câu hỏi'}\n        \n        return {'success': True}\n    \n    except Exception as e:\n        logger.exception(\"Error validating Excel format\")\n        return {'error': f'Lỗi xử lý dữ liệu Excel: {str(e)}'}\n\ndef validate_excel_file(file_path):\n    \"\"\"\n    Validates that the uploaded Excel file has at least one sheet with the required format\n    \"\"\"\n    try:\n        # Check if we can open the file as Excel\n        try:\n            excel_file = pd.ExcelFile(file_path)\n        except Exception:\n            return {'error': 'File không phải là file Excel hợp lệ'}\n        \n        # Get all sheet names\n        sheet_names = excel_file.sheet_names\n        if not sheet_names:\n            return {'error': 'File Excel không chứa sheet nào'}\n            \n        # Validate first sheet to check format\n        first_sheet = pd.read_excel(file_path, sheet_name=sheet_names[0])\n        return validate_excel_format(first_sheet)\n    \n    except Exception as e:\n        logger.exception(\"Error validating Excel file\")\n        return {'error': f'Lỗi xử lý file Excel: {str(e)}'}\n\ndef get_random_questions(df, num_questions):\n    \"\"\"\n    Gets a random sample of questions from the dataframe\n    \"\"\"\n    # Check if we have enough questions\n    total_questions = len(df)\n    if total_questions < num_questions:\n        raise ValueError(f\"Not enough questions. Requested {num_questions}, but only {total_questions} are available.\")\n    \n    # Get random sample\n    sample_indices = np.random.choice(total_questions, num_questions, replace=False)\n    sampled_questions = df.iloc[sample_indices].reset_index(drop=True)\n    \n    return sampled_questions\n","size_bytes":3484},"replit.md":{"content":"# Quiz Generator Application\n\n## Overview\n\nA Vietnamese language web application that generates randomized multiple-choice quiz exams from Excel question banks. The system allows educators to upload Excel files containing questions and answers, then automatically generates multiple versions of exams in Word document format. The application supports two output types: standard student exams and teacher versions with highlighted correct answers.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n\n**Technology Stack**: Bootstrap 5 with dark theme, vanilla JavaScript, Font Awesome icons\n\n**Design Pattern**: Server-side rendered templates with AJAX-based file upload and download\n\nThe frontend uses Flask's Jinja2 templating engine to serve a single-page application. The UI is built with Bootstrap 5's dark theme for a modern appearance and includes:\n\n- Form validation using Bootstrap's built-in validation classes\n- File upload interface with drag-and-drop support (indicated by CSS animations)\n- Loading overlay for asynchronous operations\n- Alert system for user feedback\n- Download buttons for generated exam files\n\n**Rationale**: Server-side rendering with progressive enhancement provides better initial load performance and SEO while maintaining interactivity through AJAX for file operations.\n\n### Backend Architecture\n\n**Framework**: Flask (Python web framework)\n\n**Application Structure**: Simple monolithic architecture with utility modules\n\nThe application follows a lightweight, modular structure:\n\n- `app.py`: Main Flask application with route handlers\n- `main.py`: Application entry point\n- `utils/excel_processor.py`: Excel file validation and question randomization logic\n- `utils/document_generator.py`: Word document generation with python-docx\n\n**Key Design Decisions**:\n\n1. **File Upload Handling**: Uses temporary file storage (`tempfile.gettempdir()`) to avoid persisting uploaded files, reducing security risks and storage requirements\n\n2. **Validation Layer**: Two-stage validation process - file type validation at upload, then content validation (required columns, answer format, empty values)\n\n3. **Randomization**: Supports multiple Excel sheets with uniform format, aggregating questions across sheets before random selection\n\n4. **Document Generation**: Creates landscape-oriented Word documents with customizable headers (class name, subject) and two versions (regular and answer-highlighted) packaged in ZIP files\n\n**Pros**: Simple to deploy, easy to maintain, minimal dependencies\n**Cons**: Single-threaded processing may struggle with concurrent users or large files\n\n### Data Storage Solutions\n\n**File Storage**: Temporary filesystem storage using Python's `tempfile` module\n\n**Data Processing**: In-memory processing with pandas DataFrames\n\nThe application does not use a persistent database. Instead:\n\n- Uploaded Excel files are temporarily stored during processing\n- Questions are loaded into pandas DataFrames for manipulation\n- Generated Word documents are stored temporarily before being sent to the user\n\n**Rationale**: For this use case, persistent storage is unnecessary since each session is independent. This approach reduces infrastructure complexity and eliminates data privacy concerns since no user data is retained.\n\n**Alternatives Considered**: \n- Database storage for question banks: Rejected due to added complexity for a tool meant for one-time batch processing\n- Cloud storage for generated files: Rejected to avoid vendor lock-in and reduce latency\n\n### Authentication and Authorization\n\n**Current Implementation**: None\n\nThe application does not implement authentication or authorization. It's designed as a utility tool for individual educators to use locally or in trusted environments.\n\n**Future Considerations**: If deployed publicly, would need to add session management and user accounts to prevent abuse.\n\n## External Dependencies\n\n### Python Libraries\n\n**Core Framework**:\n- `Flask`: Web framework for routing and request handling\n- `Werkzeug`: WSGI utilities (included with Flask) for secure filename handling\n\n**Data Processing**:\n- `pandas`: Excel file reading and DataFrame manipulation for question randomization\n- `numpy`: Numerical operations (used by pandas)\n- `openpyxl` or `xlrd`: Excel file format support (implicit pandas dependency)\n\n**Document Generation**:\n- `python-docx`: Word document (.docx) creation with formatting support\n  - Handles document structure, paragraphs, tables\n  - Provides text formatting (bold, font size, color)\n  - Supports page layout (orientation, margins)\n\n**File Operations**:\n- `zipfile`: Standard library for creating ZIP archives of generated documents\n- `tempfile`: Standard library for temporary file management\n\n### Frontend Libraries (CDN-hosted)\n\n**UI Framework**:\n- Bootstrap 5.x with Replit dark theme: Responsive UI components and grid system\n- Font Awesome 6.4.0: Icon library for UI elements\n\n### File Format Requirements\n\n**Input**: Excel files (.xlsx or .xls) with required columns:\n- \"Câu hỏi\" (Question)\n- \"A\", \"B\", \"C\", \"D\" (Answer options)\n- \"đáp án\" (Correct answer)\n- Optional: \"Phân loại\" (Classification/Category)\n\n**Output**: \n- Word documents (.docx) in landscape orientation\n- ZIP archives containing multiple exam versions\n\n### Environment Variables\n\n**SESSION_SECRET**: Flask session encryption key (defaults to \"default_secret_key\" if not set)\n\n### Deployment Requirements\n\n- Python 3.11+\n- Web server capable of handling file uploads (default: Flask development server on port 5000)\n- Sufficient temporary storage for concurrent file processing operations","size_bytes":5687},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.2.0\",\n    \"flask>=3.1.0\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"numpy>=2.2.5\",\n    \"openpyxl>=3.1.5\",\n    \"pandas>=2.2.3\",\n    \"psycopg2-binary>=2.9.10\",\n    \"python-docx>=1.1.2\",\n    \"werkzeug>=3.1.3\",\n    \"zipfile36>=0.1.3\",\n]\n","size_bytes":417},"README.md":{"content":"# Ứng Dụng Tạo Đề Thi Trắc Nghiệm\n\nỨng dụng web này cho phép người dùng tạo các đề thi trắc nghiệm ngẫu nhiên từ một ngân hàng câu hỏi được lưu trong file Excel.\n\n## Tính Năng\n\n- Tải lên file Excel chứa câu hỏi trắc nghiệm và đáp án\n- Hỗ trợ file Excel có nhiều sheet (tất cả các sheet đều phải có cùng định dạng)\n- Chọn ngẫu nhiên số lượng câu hỏi mong muốn từ tất cả các sheet\n- Tạo nhiều phiên bản đề thi khác nhau\n- Tải xuống file Word định dạng đẹp\n- Hỗ trợ hai phiên bản: đề thi thường và đề thi có bôi đậm đáp án đúng (dành cho giáo viên)\n\n## Yêu Cầu Hệ Thống\n\n- Python 3.11 trở lên\n- Các thư viện Python cần thiết (xem file requirements.txt)\n\n## Cài Đặt\n\n### 1. Clone Repository\n\n```bash\ngit clone https://github.com/your-username/quiz-generator.git\ncd quiz-generator\n```\n\n### 2. Tạo Môi Trường Ảo (Khuyến nghị)\n\n```bash\npython -m venv venv\n```\n\nKích hoạt môi trường ảo:\n\n- Windows:\n```bash\nvenv\\Scripts\\activate\n```\n\n- macOS/Linux:\n```bash\nsource venv/bin/activate\n```\n\n### 3. Cài Đặt Các Thư Viện Cần Thiết\n\nCài đặt các thư viện cần thiết:\n\n```bash\npip install flask flask-sqlalchemy pandas numpy python-docx werkzeug gunicorn email-validator psycopg2-binary zipfile36\n```\n\n## Chạy Ứng Dụng\n\n```bash\npython main.py\n```\n\nỨng dụng sẽ chạy tại địa chỉ http://localhost:5000\n\nVới Gunicorn (khuyến nghị cho môi trường sản xuất):\n\n```bash\ngunicorn --bind 0.0.0.0:5000 --reuse-port --reload main:app\n```\n\n## Cách Sử Dụng\n\n1. Chuẩn bị file Excel với các cột sau:\n   - `Câu hỏi`: Nội dung câu hỏi\n   - `A`: Nội dung đáp án A\n   - `B`: Nội dung đáp án B\n   - `C`: Nội dung đáp án C\n   - `D`: Nội dung đáp án D\n   - `đáp án`: Đáp án đúng (A, B, C, hoặc D)\n\n2. Mở ứng dụng trong trình duyệt và tải lên file Excel\n\n3. Nhập số lượng câu hỏi (n) và số phiên bản đề thi (m)\n\n4. Nhấn \"Tạo Đề Thi\" và tải về các file ZIP được tạo\n\n## Cấu Trúc Dự Án\n\n```\n.\n├── main.py               # File khởi động ứng dụng\n├── app.py                # Ứng dụng Flask chính\n├── requirements.txt      # Các thư viện cần thiết\n├── static/               # CSS, JavaScript, và các tài nguyên tĩnh\n├── templates/            # HTML templates\n└── utils/                # Các module hỗ trợ\n    ├── excel_processor.py  # Xử lý file Excel\n    └── document_generator.py  # Tạo tài liệu Word\n```\n\n## Đóng Góp\n\nMọi đóng góp đều được hoan nghênh. Vui lòng tạo issue hoặc pull request nếu bạn muốn đóng góp cho dự án.\n\n## Giấy Phép\n\n[MIT License](LICENSE)","size_bytes":2917},"static/css/style.css":{"content":"/* Custom styles for Quiz Generator application */\n\n/* Add some margin to the body for better spacing */\nbody {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n/* Style the file input */\n.form-control[type=\"file\"] {\n    padding: 0.5rem;\n}\n\n/* Custom styling for loading overlay */\n#loadingOverlay {\n    z-index: 9999;\n}\n\n/* Make cursor a pointer on accordion buttons for better UX */\n.accordion-button {\n    cursor: pointer;\n}\n\n/* Add animations for the file upload area */\n@keyframes pulse {\n    0% {\n        transform: scale(1);\n    }\n    50% {\n        transform: scale(1.02);\n    }\n    100% {\n        transform: scale(1);\n    }\n}\n\n.file-drop-area {\n    border: 2px dashed var(--bs-border-color);\n    border-radius: 0.375rem;\n    padding: 2rem;\n    text-align: center;\n    transition: all 0.3s ease;\n}\n\n.file-drop-area.highlight {\n    border-color: var(--bs-primary);\n    background-color: rgba(var(--bs-primary-rgb), 0.05);\n    animation: pulse 1.5s infinite ease-in-out;\n}\n\n/* Add a smooth transition effect for download buttons */\n#downloadArea .btn {\n    transition: all 0.3s ease;\n}\n\n#downloadArea .btn:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n}\n\n/* Responsive adjustments */\n@media (max-width: 768px) {\n    .card-header h1 {\n        font-size: 1.5rem;\n    }\n    \n    #downloadArea .btn {\n        width: 100%;\n        margin-bottom: 0.5rem;\n    }\n}\n","size_bytes":1427},"app.py":{"content":"import os\nimport logging\nimport tempfile\nfrom flask import Flask, render_template, request, jsonify, send_file\nimport pandas as pd\nfrom werkzeug.utils import secure_filename\nfrom utils.excel_processor import validate_excel_file, validate_excel_format, get_random_questions\nfrom utils.document_generator import generate_zip_files\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\n# Create Flask app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\", \"default_secret_key\")\n\n# Configure upload settings\nALLOWED_EXTENSIONS = {'xlsx', 'xls'}\nTEMP_FOLDER = tempfile.gettempdir()\n\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    try:\n        # Check if the post request has the file part\n        if 'excelFile' not in request.files:\n            return jsonify({'error': 'Không tìm thấy file'}), 400\n        \n        file = request.files['excelFile']\n        \n        # If user does not select file\n        if file.filename == '':\n            return jsonify({'error': 'Chưa chọn file'}), 400\n        \n        # Check if it's an allowed file type\n        if not allowed_file(file.filename):\n            return jsonify({'error': 'Loại file không hợp lệ. Vui lòng tải lên file Excel (.xlsx hoặc .xls)'}), 400\n        \n        # Get form data\n        num_questions = request.form.get('numQuestions')\n        num_versions = request.form.get('numVersions')\n        class_name = request.form.get('className', '')\n        subject_name = request.form.get('subjectName', '')\n        \n        # Validate form data\n        if not num_questions or not num_versions:\n            return jsonify({'error': 'Vui lòng nhập số câu hỏi và số phiên bản'}), 400\n        \n        try:\n            num_questions = int(num_questions)\n            num_versions = int(num_versions)\n        except ValueError:\n            return jsonify({'error': 'Số câu hỏi và số phiên bản phải là số nguyên'}), 400\n        \n        if num_questions <= 0 or num_versions <= 0:\n            return jsonify({'error': 'Số câu hỏi và số phiên bản phải là số dương'}), 400\n        \n        # Save the file to a temporary location\n        if file.filename:\n            filename = secure_filename(file.filename)\n            file_path = os.path.join(TEMP_FOLDER, filename)\n            file.save(file_path)\n        else:\n            return jsonify({'error': 'Tên file không hợp lệ'}), 400\n        \n        # Validate Excel file format\n        validation_result = validate_excel_file(file_path)\n        if 'error' in validation_result:\n            os.remove(file_path)  # Remove temporary file\n            return jsonify(validation_result), 400\n        \n        # Generate the ZIP files\n        # Read all sheets from Excel file\n        excel_file = pd.ExcelFile(file_path)\n        sheet_names = excel_file.sheet_names\n        \n        # Concatenate all sheets into one dataframe\n        all_questions = []\n        for sheet_name in sheet_names:\n            sheet_df = pd.read_excel(file_path, sheet_name=sheet_name)\n            # Validate sheet format\n            validation_result = validate_excel_format(sheet_df)\n            if 'error' in validation_result:\n                os.remove(file_path)  # Remove temporary file\n                return jsonify({'error': f'Lỗi trong sheet \"{sheet_name}\": {validation_result[\"error\"]}'}), 400\n            \n            all_questions.append(sheet_df)\n        \n        # Combine all sheets\n        questions_df = pd.concat(all_questions, ignore_index=True)\n        \n        # Make sure we have enough questions\n        total_questions = len(questions_df)\n        if total_questions < num_questions:\n            os.remove(file_path)  # Remove temporary file\n            return jsonify({'error': f'File Excel chỉ chứa {total_questions} câu hỏi từ tất cả các sheet, nhưng bạn yêu cầu {num_questions} câu'}), 400\n        \n        # Check if \"Phân loại\" column exists and validate\n        if 'Phân loại' in questions_df.columns:\n            num_categories = questions_df['Phân loại'].nunique()\n            if num_questions < num_categories:\n                os.remove(file_path)  # Remove temporary file\n                return jsonify({'error': f'Số câu hỏi ({num_questions}) phải lớn hơn hoặc bằng số phân loại ({num_categories}) để đảm bảo mỗi phân loại có ít nhất 1 câu hỏi'}), 400\n        \n        zip_files = generate_zip_files(questions_df, num_questions, num_versions, class_name, subject_name)\n        \n        # Clean up temporary file\n        os.remove(file_path)\n        \n        return jsonify({\n            'success': True,\n            'message': 'Tạo file thành công',\n            'regular_zip': zip_files['regular'],\n            'highlighted_zip': zip_files['highlighted']\n        })\n    \n    except Exception as e:\n        logger.exception(\"Error processing request\")\n        return jsonify({'error': f'Đã xảy ra lỗi: {str(e)}'}), 500\n\n@app.route('/download/<filename>')\ndef download_file(filename):\n    try:\n        file_path = os.path.join(TEMP_FOLDER, filename)\n        return send_file(file_path, as_attachment=True)\n    except Exception as e:\n        logger.exception(\"Error downloading file\")\n        return jsonify({'error': f'Đã xảy ra lỗi: {str(e)}'}), 500\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    return render_template('index.html'), 404\n\n@app.errorhandler(500)\ndef server_error(e):\n    return jsonify({'error': 'Đã xảy ra lỗi nội bộ máy chủ'}), 500\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n","size_bytes":5886}},"version":2}